# Pythonista

import location
import time
import numpy as np
from threading import Thread
#import notification
import speech
import console
from objc_util import on_main_thread

class RunningApp:
    '''
    An app that monitors time and location data during a run
    '''
    
    def __init__(self, time_interval_s=1):
        # dictionary that continuously updates with time and location data dyring the run 
        self.run = {'latitude': [], 'longitude': [], 'altitude': [], 'timestamp' : [], 'distance': [], 'cum_distance': []}
        # dictionary that holds summary statistics at the end of the run 
        self.run_statistics = {'total_distance_km': 0, 'elevation_gain_m': 0, 'max_elevation_m': 0, 'total_time_min': 0, 'speed_km_h': 0, }
        # how frequently time and location data update during the run
        self.time_interval_s = time_interval_s
        # a paramater that controls the monitoring process using user input in a Thread
        self.keep_going = True
		
    def haversine_distance(self, lat_source: float, lon_source: float, lat_destination:float, lon_destination:float):
        '''
	    Retuns the Haversine distance between two points on Earth

	    Parameters
	    ----------
	    lat_source : float
	        The latitude of the source point in DD.
	    lon_source : float
	        The longitude of the source point in DD.
	    lat_destination : float
	        The latitude of the destination point in DD.
	    lon_destination : float
	        The longitude of the destination point in DD.

	    Returns
	    -------
	    km : float
	        The distance between source and destination points in kilometers.

	    '''
        # earth's mean radius = 6,371km
        EarthRadius = 6371.0
        # convert to radians
        lon_source = np.radians(lon_source)
        lon_destination = np.radians(lon_destination)
        lat_source = np.radians(lat_source)
        lat_destination = np.radians(lat_destination)
        # haversine formula 
        dlon = lon_destination - lon_source
        dlat = lat_destination - lat_source
        a = (np.sin(dlat/2))**2 + np.cos(lat_source) * np.cos(lat_destination) * (np.sin(dlon/2.0))**2
        c = 2.0 * np.arctan2(np.sqrt(a), np.sqrt(1.0-a))
        km = EarthRadius * c
        return km
		
    def append_to_run_dict(self, other:dict):
        '''
	    Function location.get_location() generates a dictionary of time and 
        location data. This dictionary is expected to be passed as argument 
        'other' in this method. For each key of that dictionary that exists
        in the object's run dictionary, append the latest data to the object's
        run dictionary. It is expected to be called in methiod 
        update _run that continuesly updates the run dictionary'

	    Parameters
	    ----------
	    other : dict
	        A dictionary. Expected to be the dictionary generated by 
            location.get_location()

	    Returns
	    -------
	    None.

	    '''
        for key in self.run:
            if key in other:
                self.run[key].append(other[key])

    def calculate_distance(self):
        '''
	    Calculates distance and cumulative distance from the latest data in 
        the object's run dictionary. It is expected to be called in methiod 
        update _run that continuesly updates the run dictionary'

	    Returns
	    -------
	    None.

	    '''
        if len(self.run['distance']) > 0:
            distance = self.haversine_distance(self.run['latitude'][-2], self.run['longitude'][-2], self.run['latitude'][-1], self.run['longitude'][-1])
            cum_distance = self.run['cum_distance'][-1] + distance
        else:
            distance = 0
            cum_distance = 0
        self.run['distance'].append(distance)
        self.run['cum_distance'].append(cum_distance)
		
    def update_run(self):
        '''
	    Obtains current location from location.get_location() and updates the 
        object's run dictionary with data from location.get_location() and
        derived distance and cumulative distance data from 
        self.calculate_distance()'

	    Returns
	    -------
	    None.

	    '''
        here = location.get_location()
        self.append_to_run_dict(here)
        self.calculate_distance()
			
    def key_capture_thread(self):
        '''
	    A process that is run as a Thread in self.monitor_run. It takes user 
        input and stops the monitoring process by setting self.keep_going to
        Fals when the user enters 'stop'. Not case sensitive.

	    Returns
	    -------
	    None.

	    '''
        txt = input('Write "stop" to stop\n')
        while txt.lower() != 'stop':
            txt = input('Write "stop" to stop\n')
        self.keep_going = False
		
    def notify(self, distance_km: float):
        '''
	    Creates a speech notification that informs the usert how long they 
        have run.

	    Parameters
	    ----------
	    distance_km : float
	        The distance to be notified.

	    Returns
	    -------
	    None.

	    '''
        #title = 'Distance is {:.2f} km'.format(distance_km)
		#notification.schedule(sound_name='default', title=title)
        speech.say('{:.2f} km'.format(distance_km))
        
    def show_run(self):
        '''
	    Shows the object's run dictionary'

	    Returns
	    -------
	    None.

	    '''
        print(self.run)
        
    def calculate_run_statistics(self):
        self.run_statistics['total_distance_km'] = self.run['cum_distance'][-1]
        self.run_statistics['elevation_gain_m'] = max(self.run['altitude']) - self.run['altitude'][0]
        self.run_statistics['max_elevation_m'] = max(self.run['altitude']) - min(self.run['altitude'])
        self.run_statistics['total_time_min'] = (self.run['timestamp'][-1] - self.run['timestamp'][0]) / 60 
        self.run_statistics['speed_km_h'] = self.run['cum_distance'][-1] / (self.run_statistics['total_time_min'] / 60)


    def show_run_statistics(self):
        print('Distance {:.2f} km'.format(self.run_statistics['total_distance_km']))
        print('Time {:.2f} min'.format(self.run_statistics['total_time_min']))
        print('Speed {:.2f} km/h'.format(self.run_statistics['speed_km_h']))
        print('Elevation gain {:.1f} m'.format(self.run_statistics['elevation_gain_m']))
        print('Maximum elevation {:.1f} m'.format(self.run_statistics['max_elevation_m']))

    def monitor_run(self,notification_distance_km:float=1):
        '''
	    The main process. Monitors the run. 

	    Parameters
	    ----------
	    notification_distance_km : float, optional
	        The distance interval that triggers a notification. 
            The default is 1.

	    Returns
	    -------
	    None.

	    '''
        # Disable screen sleep while this process is running
        on_main_thread(console.set_idle_timer_disabled)(True)
		# Set keep going to True which may have been set to False in a previous 
        # run
        self.keep_going = True
		# Initialise a variable that will hold an updated notification distance
        updated_not_dis_km = notification_distance_km
        # Start the thread that can stop the run using user input
        Thread(target=self.key_capture_thread, args=(), name='key_capture_thread', daemon=True).start()
		# Start producing internal location updates
        location.start_updates()
        # Keep monitoring for time and location data every self.time_interval_s
        # until the user stops it. Print the cumulative distance to two decimal
        # places every self.time_interval_s
        while self.keep_going:
            time.sleep(self.time_interval_s)
            self.update_run()
            print('{:.4f}'.format(self.run['cum_distance'][-1]))
            # If the notification distance is reached, notify the user and
            # update the notification distance
            if self.run['cum_distance'][-1] >= updated_not_dis_km:
                self.notify(updated_not_dis_km)
                updated_not_dis_km = updated_not_dis_km + notification_distance_km
        # Calculate run statistics
        self.calculate_run_statistics()
        # Stop producing internal location updates internally
        location.stop_updates()
        # Reanable screen sleep
        on_main_thread(console.set_idle_timer_disabled)(False)
		# Print a message for the user
        print('Stopped\n\n')
        # Print the run's statistics
        self.show_run_statistics()